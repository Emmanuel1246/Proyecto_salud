# Proyecto_salud
Predicción de lunares malignos a través de redes neuronales
# -*- coding: utf-8 -*-
"""Salud.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LoV8azpU2hPX3j06t-Yq47pleQBEIDng
"""

#conectar con google
from google.colab import drive
drive.mount('/content/drive')

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os
from glob import glob
import seaborn as sns
from PIL import Image

np.random.seed(42)
from sklearn.metrics import confusion_matrix

import keras
from keras.utils.np_utils import to_categorical # used for converting labels to one-hot-encoding
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, BatchNormalization
from sklearn.model_selection import train_test_split
from scipy import stats
from sklearn.preprocessing import LabelEncoder

skin_df = pd.read_csv('/content/drive/MyDrive/Analitica III/SALUD/salud/HAM10000_metadata.csv')

SIZE=64

# label encoding para los tipos de lunares
le = LabelEncoder()
le.fit(skin_df['dx'])
LabelEncoder()
print(list(le.classes_))
 
skin_df['label'] = le.transform(skin_df["dx"]) 
print(skin_df.sample(10))

# Data distribution 
fig = plt.figure(figsize=(15,10))

ax1 = fig.add_subplot(221)
skin_df['dx'].value_counts().plot(kind='bar', ax=ax1)
ax1.set_ylabel('Conteo')
ax1.set_title('Tipo de célula');

ax2 = fig.add_subplot(222)
skin_df['sex'].value_counts().plot(kind='bar', ax=ax2)
ax2.set_ylabel('Conteo', size=15)
ax2.set_title('Sexo');

ax3 = fig.add_subplot(223)
skin_df['localization'].value_counts().plot(kind='bar')
ax3.set_ylabel('Counteo',size=12)
ax3.set_title('ubicación')


ax4 = fig.add_subplot(224)
sample_age = skin_df[pd.notnull(skin_df['age'])]
sns.distplot(sample_age['age'], fit=stats.norm, color='red');
ax4.set_title('Edad')

plt.tight_layout()
plt.show()

# Crear la nueva columna que indica si la lesión es maligna o benigna
skin_df['label2'] = skin_df['dx'].apply(lambda x: 1 if x in ['akiec', 'bcc', 'mel'] else 0)
skin_df=skin_df.drop(['label'], axis=1)
# Mostrar el dataframe resultante
skin_df

# Distribucion de los datos segun su clase
from sklearn.utils import resample
print(skin_df['label2'].value_counts())

#Balanceo de datos.

df_0 = skin_df[skin_df['label2'] == 0]
df_1 = skin_df[skin_df['label2'] == 1]

n_samples0=3000
n_samples1=1954
df_0_balanced = resample(df_0, replace=True, n_samples=n_samples0, random_state=42) 
df_1_balanced = resample(df_1, replace=True, n_samples=n_samples1, random_state=42) 


skin_df_balanced = pd.concat([df_0_balanced,df_1_balanced])

print(skin_df_balanced['label2'].value_counts())

skin_df_balanced

#guardar la tabla en formato csv
ruta = '/content/drive/MyDrive/Analitica III/SALUD/tablaimgg.csv'
skin_df_balanced.to_csv(ruta , index=False)
